# file: .github/workflows/reusable-super-linter.yml
# version: 2.4.3
# guid: b2c3d4e5-f6a7-89bc-def0-123456789bcd

name: Reusable - Super Linter

on:
  workflow_call:
    inputs:
      validate-all-codebase:
        description: "Validate entire codebase instead of just changed files"
        required: false
        default: false
        type: boolean
      default-branch:
        description: "The default branch of the repository"
        required: false
        default: "main"
        type: string
      config-file:
        description: "Path to Super Linter configuration file"
        required: false
        default: ".github/super-linter.env"
        type: string
      filter-regex-exclude:
        description: "Regex to exclude files from linting"
        required: false
        default: ".*\\.git/.*|.*\\.github/copilot/.*|.*\\.vscode/.*|.*node_modules/.*|.*\\.cache/.*"
        type: string
      run-python:
        description: "Enable Python linting"
        required: false
        default: true
        type: boolean
      run-shell:
        description: "Enable shell script linting"
        required: false
        default: true
        type: boolean
      run-markdown:
        description: "Enable Markdown linting"
        required: false
        default: true
        type: boolean
      run-yaml:
        description: "Enable YAML linting"
        required: false
        default: true
        type: boolean
      run-json:
        description: "Enable JSON linting"
        required: false
        default: true
        type: boolean
      run-javascript:
        description: "Enable JavaScript/TypeScript linting"
        required: false
        default: true
        type: boolean
      run-go:
        description: "Enable Go linting"
        required: false
        default: true
        type: boolean
      run-css:
        description: "Enable CSS linting"
        required: false
        default: true
        type: boolean
      run-html:
        description: "Enable HTML linting"
        required: false
        default: true
        type: boolean
      run-github-actions:
        description: "Enable GitHub Actions linting"
        required: false
        default: true
        type: boolean
      run-security:
        description: "Enable security scanning (secrets, Dockerfile)"
        required: false
        default: true
        type: boolean
      enable-auto-fix:
        description: "Enable auto-fixing for supported linters and formatters"
        required: false
        default: true
        type: boolean
      auto-commit-fixes:
        description: "Automatically commit and push fixes when running on main branch or PRs"
        required: false
        default: true
        type: boolean
      commit-message:
        description: "Commit message for auto-fixes"
        required: false
        default: "style: auto-fix linting issues [skip ci]"
        type: string
      show-detailed-summary:
        description: "Show detailed processing information instead of just issues and changes"
        required: false
        default: false
        type: boolean

    secrets:
      github-token:
        description: "GitHub token with necessary permissions for linting and auto-fix"
        required: false

jobs:
  super-linter:
    name: Super Linter
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          # Full git history is needed to get list of changed files
          fetch-depth: 0
          token: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}

      - name: Setup Super Linter environment
        run: |
          echo "Setting up Super Linter environment..."
          echo "VALIDATE_ALL_CODEBASE=${{ inputs.validate-all-codebase }}" >> $GITHUB_ENV
          echo "DEFAULT_BRANCH=${{ inputs.default-branch }}" >> $GITHUB_ENV
          echo "FILTER_REGEX_EXCLUDE=${{ inputs.filter-regex-exclude }}" >> $GITHUB_ENV

      - name: Load custom configuration
        run: |
          if [ -f "${{ inputs.config-file }}" ]; then
            echo "Loading custom configuration from ${{ inputs.config-file }}"
            # Filter out comments and empty lines when loading config
            grep -v '^#' "${{ inputs.config-file }}" | grep -v '^$' >> $GITHUB_ENV
          else
            echo "No custom configuration file found at ${{ inputs.config-file }}"
          fi

      - name: Run Super Linter
        id: run-super-linter
        uses: super-linter/super-linter@v8
        continue-on-error: true
        env:
          # Basic configuration
          DEFAULT_BRANCH: ${{ inputs.default-branch }}
          GITHUB_TOKEN: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}
          VALIDATE_ALL_CODEBASE: ${{ inputs.validate-all-codebase }}
          FILTER_REGEX_EXCLUDE: ${{ inputs.filter-regex-exclude }}

          # Output and display settings
          SUPPRESS_POSSUM: true
          LOG_LEVEL: ${{ inputs.show-detailed-summary && 'VERBOSE' || 'WARN' }}
          OUTPUT_FORMAT: colored
          OUTPUT_FOLDER: super-linter-output
          OUTPUT_DETAILS: ${{ inputs.show-detailed-summary && 'detailed' || 'simpler' }}
          CREATE_LOG_FILE: true
          SLIM_IMAGE: false

          # Ensure logs are written to the expected location
          LOG_FILE: super-linter.log

          # Language validation settings
          VALIDATE_PYTHON: ${{ inputs.run-python }}
          VALIDATE_PYTHON_BLACK: ${{ inputs.run-python }}
          VALIDATE_PYTHON_FLAKE8: ${{ inputs.run-python }}
          VALIDATE_PYTHON_ISORT: ${{ inputs.run-python }}

          VALIDATE_BASH: ${{ inputs.run-shell }}
          VALIDATE_SHELL_SHFMT: ${{ inputs.run-shell }}

          VALIDATE_MARKDOWN: ${{ inputs.run-markdown }}
          VALIDATE_YAML: ${{ inputs.run-yaml }}
          VALIDATE_JSON: ${{ inputs.run-json }}

          VALIDATE_JAVASCRIPT_ES: ${{ inputs.run-javascript }}
          VALIDATE_TYPESCRIPT_ES: ${{ inputs.run-javascript }}
          VALIDATE_JAVASCRIPT_PRETTIER: ${{ inputs.run-javascript }}
          VALIDATE_TYPESCRIPT_PRETTIER: ${{ inputs.run-javascript }}

          VALIDATE_GO: ${{ inputs.run-go }}
          VALIDATE_GO_MODULES: ${{ inputs.run-go }}

          VALIDATE_CSS: ${{ inputs.run-css }}
          VALIDATE_HTML: ${{ inputs.run-html }}

          VALIDATE_GITHUB_ACTIONS: ${{ inputs.run-github-actions }}
          VALIDATE_GITLEAKS: ${{ inputs.run-security }}
          VALIDATE_DOCKERFILE_HADOLINT: ${{ inputs.run-security }}

          # Auto-fix settings (enable for supported linters)
          FIX_GO: ${{ inputs.enable-auto-fix && inputs.run-go }}
          FIX_JAVASCRIPT_ES: ${{ inputs.enable-auto-fix && inputs.run-javascript }}
          FIX_TYPESCRIPT_ES: ${{ inputs.enable-auto-fix && inputs.run-javascript }}
          FIX_JSON: ${{ inputs.enable-auto-fix }}
          FIX_MARKDOWN: ${{ inputs.enable-auto-fix }}
          FIX_PYTHON_BLACK: ${{ inputs.enable-auto-fix && inputs.run-python }}
          FIX_PYTHON_ISORT: ${{ inputs.enable-auto-fix && inputs.run-python }}
          FIX_SHELL_SHFMT: ${{ inputs.enable-auto-fix && inputs.run-shell }}

      - name: Check for auto-fixes
        if: inputs.enable-auto-fix == true
        id: check-fixes
        run: |
          if ! git diff --quiet; then
            echo "has_fixes=true" >> $GITHUB_OUTPUT
            echo "Auto-fixes were applied by Super Linter"
          else
            echo "has_fixes=false" >> $GITHUB_OUTPUT
            echo "No auto-fixes were applied"
          fi

      - name: Commit and push auto-fixes
        if: steps.check-fixes.outputs.has_fixes == 'true' && inputs.auto-commit-fixes == true
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          echo "Staging auto-fixes..."
          git add -A

          # Create detailed commit message
          FIXED_FILES=$(git diff --cached --name-only | head -10)
          TOTAL_FILES=$(git diff --cached --name-only | wc -l)

          echo "${{ inputs.commit-message }}" > commit_msg.txt
          echo "" >> commit_msg.txt
          echo "Auto-formatting and fixes applied by Super Linter." >> commit_msg.txt
          echo "" >> commit_msg.txt
          echo "Files changed:" >> commit_msg.txt

          echo "$FIXED_FILES" | while IFS= read -r file; do
            echo "- $file - Auto-formatting applied" >> commit_msg.txt
          done

          if [ "$TOTAL_FILES" -gt 10 ]; then
            echo "- ... and $((TOTAL_FILES - 10)) more files" >> commit_msg.txt
          fi

          git commit -F commit_msg.txt
          rm commit_msg.txt

          echo "Pushing auto-fixes..."
          git push
          echo "âœ… Auto-fixes committed and pushed successfully"

      - name: Create Job Summary
        if: always()
        run: |
          echo "# ðŸ” Super Linter Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.run-super-linter.outcome }}" = "success" ]; then
            echo "âœ… **All code quality checks passed!**" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.run-super-linter.outcome }}" = "failure" ]; then
            echo "âŒ **Issues found that need attention**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Issues to Address" >> $GITHUB_STEP_SUMMARY

            # Print all error lines from log files
            if [ -d "super-linter-output" ]; then
              # Use process substitution to avoid subshell issues with piped while loop
              while IFS= read -r -d '' logfile; do
                if [ -f "$logfile" ] && grep -q "ERROR\|FAIL\|error:" "$logfile" 2>/dev/null; then
                  linter_name=$(basename "$logfile" .log | sed 's/^.*-//')
                  echo "### $linter_name" >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  grep -E "ERROR|FAIL|error:" "$logfile" >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                fi
              done < <(find super-linter-output -name "*.log" -type f -print0 | sort -z)
            fi
          else
            echo "âš ï¸ **Linter status unknown** - check workflow logs" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Show auto-fixes if applied
          if [ "${{ steps.check-fixes.outputs.has_fixes }}" = "true" ]; then
            echo "## ðŸ”§ Auto-fixes Applied" >> $GITHUB_STEP_SUMMARY
            if [ "${{ inputs.auto-commit-fixes }}" = "true" ]; then
              echo "Auto-formatting fixes were applied and committed." >> $GITHUB_STEP_SUMMARY
            else
              echo "Auto-formatting fixes were applied but not committed." >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "## Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Mode**: ${{ inputs.validate-all-codebase && 'Full codebase validation' || 'Changed files only' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Auto-fix**: ${{ inputs.enable-auto-fix }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Auto-commit**: ${{ inputs.auto-commit-fixes }}" >> $GITHUB_STEP_SUMMARY

      - name: Prepare Super Linter outputs
        if: always()
        run: |
          # Ensure output directory exists
          mkdir -p super-linter-output

          # Debug: Show current directory and contents
          echo "Current directory: $(pwd)"
          echo "Contents of current directory:"
          ls -la

          # Look for Super Linter log files in multiple possible locations
          echo "Searching for Super Linter log files..."

          # Copy main log file if it exists
          if [ -f "super-linter.log" ]; then
            echo "Found super-linter.log, copying to output directory"
            cp super-linter.log super-linter-output/
          else
            echo "super-linter.log not found in current directory"
          fi

          # Check if logs exist in the default Super Linter output location
          if [ -d "/tmp/super-linter-output" ]; then
            echo "Found logs in /tmp/super-linter-output, copying..."
            cp -r /tmp/super-linter-output/* super-linter-output/ 2>/dev/null || true
          fi

          # Check for any .log files in current directory
          find . -maxdepth 1 -name "*.log" -type f | while read -r logfile; do
            if [ -f "$logfile" ]; then
              echo "Found log file: $logfile"
              cp "$logfile" super-linter-output/
            fi
          done

          # List what we have in the output directory
          echo "Contents of super-linter-output directory:"
          if [ -d "super-linter-output" ]; then
            ls -la super-linter-output/
            count=$(find super-linter-output -name "*.log" -type f | wc -l)
            echo "Total log files found: $count"
          else
            echo "super-linter-output directory still does not exist!"
          fi

          # Create a focused summary file with only relevant information
          echo "Super Linter Summary" > super-linter-output/summary.txt
          echo "===================" >> super-linter-output/summary.txt
          echo "Execution Date: $(date)" >> super-linter-output/summary.txt
          echo "Validation Mode: ${{ inputs.validate-all-codebase && 'Full codebase' || 'Changed files only' }}" >> super-linter-output/summary.txt
          echo "Outcome: ${{ steps.run-super-linter.outcome }}" >> super-linter-output/summary.txt
          echo "" >> super-linter-output/summary.txt

          # Extract actual errors and fixes applied
          if [ "${{ steps.run-super-linter.outcome }}" = "failure" ]; then
            echo "Issues Found:" >> super-linter-output/summary.txt
            echo "=============" >> super-linter-output/summary.txt

            # Include error lines from each log file
            while IFS= read -r -d '' logfile; do
              if [ -f "$logfile" ] && grep -q "ERROR\|FAIL\|error:" "$logfile" 2>/dev/null; then
                echo "" >> super-linter-output/summary.txt
                echo "$(basename "$logfile")" >> super-linter-output/summary.txt
                echo "-------------------" >> super-linter-output/summary.txt
                grep -E "ERROR|FAIL|error:" "$logfile" >> super-linter-output/summary.txt
              fi
            done < <(find super-linter-output -name "*.log" -type f -print0 2>/dev/null | sort -z)
          else
            echo "âœ… No linting issues found" >> super-linter-output/summary.txt
          fi

          # Show auto-fixes if any were applied
          if [ "${{ steps.check-fixes.outputs.has_fixes }}" = "true" ]; then
            echo "" >> super-linter-output/summary.txt
            echo "Auto-fixes Applied:" >> super-linter-output/summary.txt
            echo "==================" >> super-linter-output/summary.txt
            while IFS= read -r file; do
              if [ -n "$file" ]; then
                echo "- $file" >> super-linter-output/summary.txt
              fi
            done < <(git diff --name-only HEAD~1 2>/dev/null | head -10)
          fi

      - name: Upload Super Linter results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: super-linter-output
          path: super-linter-output/
          retention-days: 7
          if-no-files-found: warn

      - name: Comment PR with linting results
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          AUTO_COMMIT_ENABLED: ${{ inputs.auto-commit-fixes }}
        with:
          github-token: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            // Skip if not a pull request
            if (!context.payload.pull_request) {
              console.log('Not a pull request, skipping summary comment');
              return;
            }

            const linterOutcome = '${{ steps.run-super-linter.outcome }}' || 'unknown';
            const autoFixEnabled = '${{ inputs.enable-auto-fix }}' === 'true';
            const autoCommitEnabled = process.env.AUTO_COMMIT_ENABLED === 'true';
            const hasAutoFixes = '${{ steps.check-fixes.outputs.has_fixes }}' === 'true';

            let summary = '## ðŸ” Super Linter Results\n\n';

            // Add concise status
            if (linterOutcome === 'success') {
              summary += 'âœ… **All code quality checks passed!**\n\n';
            } else if (linterOutcome === 'failure') {
              summary += 'âŒ **Code quality issues found**\n\n';
            } else {
              summary += 'âš ï¸ **Linter status unknown**\n\n';
            }

            // Show auto-fix information if relevant
            if (autoFixEnabled && hasAutoFixes && autoCommitEnabled) {
              summary += 'ðŸ”§ **Auto-fixes applied and committed**\n\n';
            } else if (autoFixEnabled && hasAutoFixes) {
              summary += 'ðŸ”§ **Auto-fixes applied (not committed)**\n\n';
            }

            // For failures, show specific actionable issues
            if (linterOutcome === 'failure') {
              summary += '### Issues to Fix\n\n';

              let issuesFound = false;
              try {
                console.log('Checking for super-linter-output directory...');
                if (fs.existsSync('super-linter-output')) {
                  console.log('super-linter-output directory found');
                  let logFiles;
                  try {
                    logFiles = fs.readdirSync('super-linter-output').filter(f => f.endsWith('.log'));
                    console.log(`Found ${logFiles.length} log files:`, logFiles);
                  } catch (dirError) {
                    console.log('Error reading super-linter-output directory:', dirError.message);
                    logFiles = [];
                  }
                  let issueCount = 0;

                  for (const logFile of logFiles.slice(0, 3)) { // Limit to first 3 log files
                    if (issueCount >= 5) break; // Limit total issues shown

                    const logPath = `super-linter-output/${logFile}`;
                    if (!fs.existsSync(logPath)) {
                      console.log(`Log file not found: ${logPath}`);
                      continue;
                    }

                    let logContent;
                    try {
                      logContent = fs.readFileSync(logPath, 'utf8');
                    } catch (readError) {
                      console.log(`Error reading log file ${logPath}:`, readError.message);
                      continue;
                    }

                    const lines = logContent.split('\n');

                    // Extract specific error lines with file context
                    const errors = lines.filter(line => {
                      const l = line.toLowerCase();
                      return (l.includes('error') || l.includes('fail')) &&
                             (l.includes('.go') || l.includes('.py') || l.includes('.js') ||
                              l.includes('.md') || l.includes('.yml') || l.includes('.yaml') ||
                              l.includes('.json') || l.includes('.sh'));
                    }).slice(0, 2); // Max 2 errors per log file

                    if (errors.length > 0) {
                      const linterType = logFile.replace('.log', '').replace(/^.*-/, '');
                      summary += `**${linterType.toUpperCase()}:**\n`;
                      errors.forEach(error => {
                        if (error.trim() && issueCount < 5) {
                          // Clean up the error message
                          let cleanError = error.trim()
                            .replace(/^\d+:\d+:\d+\s*/, '') // Remove timestamps
                            .replace(/^.*super-linter.*?:/, '') // Remove super-linter prefix
                            .replace(/^.*ERROR.*?:/, '') // Remove ERROR prefix
                            .trim();

                          if (cleanError.length > 100) {
                            cleanError = cleanError.substring(0, 100) + '...';
                          }

                          summary += `- ${cleanError}\n`;
                          issueCount++;
                          issuesFound = true;
                        }
                      });
                      summary += '\n';
                    }
                  }
                } else {
                  console.log('super-linter-output directory not found');
                  summary += 'No detailed error logs available. Check the Super Linter step for more information.\n\n';
                }
              } catch (error) {
                console.log('Error accessing super-linter output:', error.message);
                summary += 'Error accessing linting logs. Check the workflow logs for detailed error information.\n\n';
              }

              if (!issuesFound) {
                summary += 'Check the workflow logs for detailed error information.\n\n';
              }

              summary += '### Next Steps\n';
              summary += '1. Fix the issues listed above\n';
              summary += '2. Push changes to update this PR\n';
              if (autoFixEnabled) {
                summary += '3. Some formatting issues may auto-fix on next run\n';
              }
              summary += '\n';
            }

            // Only show minimal config for debugging if needed
            if (linterOutcome !== 'success') {
              summary += '<details>\n<summary>ðŸ”§ Configuration</summary>\n\n';
              summary += `- Mode: ${{ inputs.validate-all-codebase && 'Full codebase' || 'Changed files only' }}\n`;
              summary += `- Auto-fix: ${{ inputs.enable-auto-fix }}\n`;
              summary += `- Auto-commit: ${{ inputs.auto-commit-fixes }}\n`;
              summary += '\n</details>\n\n';
            }

            summary += '*View detailed logs in the workflow run artifacts*';

            // Find and update existing comment or create new one
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Super Linter Results')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: summary
              });
              console.log('Updated existing Super Linter comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
              console.log('Created new Super Linter comment');
            }

      - name: Fail if linting errors remain
        if: steps.run-super-linter.outcome == 'failure'
        run: exit 1
