# file: .github/workflows/reusable-ai-rebase.yml
# version: 1.4.0
# guid: 8baaa277-345e-4c24-8659-47c93e0f3a8d

name: Reusable - AI Rebase Conflicted PRs

on:
  workflow_call:
    inputs:
      base-branch:
        description: "Branch to rebase onto"
        required: false
        default: "main"
        type: string
      model:
        description: "Model to use for inference"
        required: false
        default: "gpt-4o-mini"
        type: string
      operation:
        description: "Operation type for the workflow"
        required: false
        default: "all"
        type: string
    secrets:
      github-token:
        description: "GitHub token with write access"
        required: true
      claude-api-key:
        description: "Claude API key for fallback AI processing"
        required: false

# Permissions removed - should be set in calling workflow
# See: https://docs.github.com/en/actions/using-workflows/reusing-workflows#supported-keywords-for-jobs-that-call-a-reusable-workflow
jobs:
  find:
    runs-on: ubuntu-latest
    outputs:
      list: ${{ steps.find.outputs.list }}
    steps:
      - uses: actions/github-script@v7
        id: find
        with:
          github-token: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}
          script: |
            const prs = await github.paginate(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });
            const conflicted = [];
            for (const pr of prs) {
              let full = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
              });

              // GitHub may return 'unknown' mergeable_state on first request
              if (full.data.mergeable_state === 'unknown') {
                await new Promise(r => setTimeout(r, 2000));
                full = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                });
              }

              const state = full.data.mergeable_state;
              core.info(`PR #${pr.number} state: ${state}`);
              if (state === 'dirty' || state === 'behind') {
                conflicted.push({ number: pr.number, branch: pr.head.ref });
              }
            }
            core.setOutput('list', JSON.stringify(conflicted));
            core.info(`Found ${conflicted.length} conflicted PR(s)`);

  rebase:
    runs-on: ubuntu-latest
    needs: find
    if: needs.find.outputs.list != '[]'
    strategy:
      matrix:
        pr: ${{ fromJson(needs.find.outputs.list) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare branch
        env:
          PR_BRANCH: ${{ matrix.pr.branch }}
          BASE_BRANCH: ${{ inputs.base-branch }}
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          print_status "Fetching and rebasing branch $PR_BRANCH onto $BASE_BRANCH"
          git fetch origin "${PR_BRANCH}"
          git checkout -B "${PR_BRANCH}" "origin/${PR_BRANCH}"
          git rebase "origin/${BASE_BRANCH}" || print_error "Rebase failed, continuing for conflict detection"

      - name: Detect conflicts
        id: conflicts
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          if git ls-files -u | grep -q .; then
            print_status "Conflicts detected"
            echo "has_conflict=true" >> "$GITHUB_OUTPUT"
          else
            print_success "No conflicts detected"
            echo "has_conflict=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Collect conflict information
        if: steps.conflicts.outputs.has_conflict == 'true'
        id: conflict_info
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          print_status "Collecting conflict information"
          echo "=== Conflicted Files ===" > conflict_summary.txt
          conflicted_files=$(git ls-files -u | cut -f2 | sort -u)
          echo "$conflicted_files" >> conflict_summary.txt
          echo "" >> conflict_summary.txt

          echo "=== Conflict Count ===" >> conflict_summary.txt
          echo "Total conflicted files: $(echo "$conflicted_files" | wc -l)" >> conflict_summary.txt
          echo "" >> conflict_summary.txt

          # Instead of dumping full file contents, create manageable conflict context
          echo "=== Conflict Preview ===" >> conflict_summary.txt
          for file in $conflicted_files; do
            echo "--- File: $file ---" >> conflict_summary.txt
            # Only include conflict markers and surrounding context (max 50 lines per file)
            if [ -f "$file" ]; then
              grep -n -A 3 -B 3 "^<<<<<<< |^======= |^>>>>>>> " "$file" 2>/dev/null | head -50 >> conflict_summary.txt || true
            fi
            echo "" >> conflict_summary.txt
          done

          print_status "Conflict summary written to conflict_summary.txt"
          echo "has_conflicts=true" >> "$GITHUB_OUTPUT"
          echo "conflict_count=$(echo "$conflicted_files" | wc -l)" >> "$GITHUB_OUTPUT"

      - name: Prepare repository context
        if: steps.conflicts.outputs.has_conflict == 'true'
        run: |
          # Create repository context file by combining template with actual repo content
          if [ -f ".github/prompts/ai-rebase-context.md" ]; then
            echo "Using repository-specific AI rebase context"
            cp .github/prompts/ai-rebase-context.md repo_context.txt
          else
            echo "Creating minimal context from repository files"
            # Create minimal context if repo-specific file doesn't exist
            cat <<EOF > repo_context.txt
          # Repository Context

          ## Project: ${{ github.repository }}

          ## Project Overview
          EOF

            # Add project description from README
            if [ -f "README.md" ]; then
              echo "### README.md (excerpt)" >> repo_context.txt
              # Extract the first paragraph after the title
              sed -n '1,/^##/p' README.md | head -20 >> repo_context.txt
              echo "" >> repo_context.txt
            fi

            # Add coding standards
            if [ -f ".github/instructions/general-coding.instructions.md" ]; then
              echo "### Coding Standards" >> repo_context.txt
              head -30 .github/instructions/general-coding.instructions.md >> repo_context.txt
              echo "" >> repo_context.txt
            fi

            # Add commit message guidelines
            if [ -f ".github/commit-messages.md" ]; then
              echo "### Commit Message Format" >> repo_context.txt
              head -20 .github/commit-messages.md >> repo_context.txt
              echo "" >> repo_context.txt
            fi

            # Add language-specific information
            echo "### Project Structure" >> repo_context.txt
            if [ -f "go.mod" ]; then
              echo "- Go project with modules" >> repo_context.txt
              echo "- Main module: $(head -1 go.mod)" >> repo_context.txt
            fi
            if [ -f "package.json" ]; then
              echo "- Node.js/JavaScript project" >> repo_context.txt
            fi
            if [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
              echo "- Python project" >> repo_context.txt
            fi
            if [ -f "Dockerfile" ]; then
              echo "- Dockerized application" >> repo_context.txt
            fi
            echo "" >> repo_context.txt

            # Add important directories
            echo "### Key Directories" >> repo_context.txt
            for dir in src pkg cmd internal lib app components; do
              if [ -d "$dir" ]; then
                echo "- \`$dir/\` - $(find "$dir" -name "*.go" -o -name "*.js" -o -name "*.py" -o -name "*.ts" | wc -l | tr -d ' ') source files" >> repo_context.txt
              fi
            done
            echo "" >> repo_context.txt
          fi

      - name: Prepare system prompt
        if: steps.conflicts.outputs.has_conflict == 'true'
        run: |
          # Combine system prompt with repository context
          cat .github/prompts/ai-rebase-system.prompt.md > system_prompt.txt
          echo "" >> system_prompt.txt
          echo "## Repository Context" >> system_prompt.txt
          cat repo_context.txt >> system_prompt.txt

      - name: Prepare AI prompt
        if: steps.conflicts.outputs.has_conflict == 'true'
        env:
          PR_BRANCH: ${{ matrix.pr.branch }}
          BASE_BRANCH: ${{ inputs.base-branch }}
          REPOSITORY: ${{ github.repository }}
        run: |
          # Create a more focused, smaller prompt for AI conflict resolution
          cat <<EOF > prompt.txt
          I need help resolving merge conflicts during rebase.

          **Context:**
          - Branch: ${PR_BRANCH}
          - Base: ${BASE_BRANCH}
          - Repository: ${REPOSITORY}
          - Files: $(git ls-files -u | cut -f2 | sort -u | wc -l)

          **Conflicts (summary only):**
          EOF

          # Only include conflict markers and minimal context, not full files
          conflict_count=0
          for file in $(git ls-files -u | cut -f2 | sort -u | head -5); do  # Limit to 5 files
            if [ $conflict_count -ge 5 ]; then
              echo "... and $(( $(git ls-files -u | cut -f2 | sort -u | wc -l) - 5 )) more files" >> prompt.txt
              break
            fi
            echo "### $file" >> prompt.txt
            if [ -f "$file" ]; then
              echo '```' >> prompt.txt
              # Only show lines around conflict markers
              grep -n -A 2 -B 2 "^<<<<<<< \|^======= \|^>>>>>>> " "$file" | head -20 >> prompt.txt 2>/dev/null || echo "No conflict markers visible" >> prompt.txt
              echo '```' >> prompt.txt
            fi
            echo "" >> prompt.txt
            conflict_count=$((conflict_count + 1))
          done

          cat <<'EOF' >> prompt.txt

          **Task:** Provide a git patch to resolve these conflicts by:
          1. Keeping both changes where possible
          2. Following semantic versioning for version updates
          3. Merging documentation changes intelligently
          4. Maintaining proper file headers and structure

          Output ONLY the patch in unified diff format.
          EOF

          # Add debug information
          print_status "Prepared AI prompt for model: ${{ inputs.model }}"
          print_status "Prompt size: $(wc -c < prompt.txt) characters"
          print_status "System prompt size: $(wc -c < system_prompt.txt) characters"

      - name: Generate patch with AI
        if: steps.conflicts.outputs.has_conflict == 'true'
        id: ai
        uses: actions/ai-inference@v1.2.8
        continue-on-error: true
        with:
          token: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}
          model: ${{ inputs.model }}
          system-prompt-file: system_prompt.txt
          prompt-file: prompt.txt
          max-tokens: 2000

      - name: Handle AI inference failure
        if: steps.conflicts.outputs.has_conflict == 'true' && steps.ai.outcome == 'failure'
        env:
          GH_TOKEN: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          print_error "AI inference failed. This may be due to:"
          print_error "1. GitHub AI service availability"
          print_error "2. Token permissions (needs 'models' scope)"
          print_error "3. Prompt size exceeding limits"
          print_error "4. Rate limiting"

          # Create a manual resolution comment
          gh pr comment ${{ matrix.pr.number }} --body "âš ï¸ AI rebase failed to resolve conflicts automatically. Manual resolution required.

          **Conflicted files:**
          $(cat conflict_summary.txt | grep -E '^[^-=].*\.(go|md|proto)$' || echo 'See workflow logs for details')

          **Next steps:**
          1. Checkout the branch locally: \`git checkout ${{ matrix.pr.branch }}\`
          2. Run \`git rebase ${{ inputs.base-branch }}\`
          3. Resolve conflicts manually
          4. Push the resolved changes: \`git push --force-with-lease origin ${{ matrix.pr.branch }}\`

          **AI Error Details:**
          The GitHub AI inference service failed to process the conflict resolution request." || true

      - name: Fallback to Claude API (if available)
        if: steps.conflicts.outputs.has_conflict == 'true' && steps.ai.outcome == 'failure' && env.CLAUDE_API_KEY != ''
        id: claude_fallback
        env:
          CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          if [ -z "$CLAUDE_API_KEY" ]; then
            print_status "No Claude API key available, skipping fallback"
            exit 0
          fi

          print_status "Attempting fallback to Claude API"

          # Prepare a simplified prompt for Claude
          prompt_content=$(cat prompt.txt | jq -R -s .)

          response=$(curl -s -X POST https://api.anthropic.com/v1/messages \
            -H "Content-Type: application/json" \
            -H "x-api-key: $CLAUDE_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d "{
              \"model\": \"claude-3-sonnet-20240229\",
              \"max_tokens\": 2000,
              \"system\": \"You are a Git merge conflict resolution expert. Provide only unified diff patches.\",
              \"messages\": [{\"role\": \"user\", \"content\": $prompt_content}]
            }")

          if echo "$response" | jq -e '.content[0].text' > /dev/null 2>&1; then
            echo "$response" | jq -r '.content[0].text' > claude_patch.txt
            print_success "Claude API provided response"
            echo "claude_success=true" >> "$GITHUB_OUTPUT"
          else
            print_error "Claude API also failed: $(echo "$response" | jq -r '.error.message // "Unknown error"')"
            echo "claude_success=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Apply Claude patch
        if: steps.conflicts.outputs.has_conflict == 'true' && steps.claude_fallback.outputs.claude_success == 'true'
        id: apply_claude_patch
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          print_status "Applying Claude-generated patch"

          if git apply --check claude_patch.txt 2>/dev/null; then
            print_success "Claude patch validation successful, applying patch"
            git apply claude_patch.txt
            git add -A
            print_success "Applied Claude-generated patch successfully"
          else
            print_error "Claude patch validation failed, using fallback resolution"
            # Same fallback as before
            for file in $(git ls-files -u | cut -f2 | sort -u); do
              print_status "Resolving conflicts in $file using fallback strategy..."
              if [[ "$file" == *.md ]] || [[ "$file" == *README* ]] || [[ "$file" == *CHANGELOG* ]]; then
                git checkout --theirs "$file" 2>/dev/null || git checkout --ours "$file" 2>/dev/null || true
              else
                git checkout --theirs "$file" 2>/dev/null || git checkout --ours "$file" 2>/dev/null || true
              fi
            done
            git add -A
            print_status "Applied fallback conflict resolution"
          fi

          if git ls-files -u | grep -q .; then
            print_error "Some conflicts remain unresolved after Claude attempt"
            exit 1
          fi

          git rebase --continue || print_status "Rebase completed with Claude-resolved conflicts"

      - name: Apply AI patch
        if: steps.conflicts.outputs.has_conflict == 'true' && steps.ai.outcome == 'success'
        id: apply_patch
        env:
          PR_BRANCH: ${{ matrix.pr.branch }}
          AI_RESPONSE: ${{ steps.ai.outputs.response }}
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          if [ -z "$AI_RESPONSE" ]; then
            print_error "AI response is empty"
            exit 1
          fi

          print_status "Applying AI-generated patch"
          echo "$AI_RESPONSE" > ai_patch.patch

          # Show patch for debugging
          print_status "AI generated patch preview:"
          head -20 ai_patch.patch || true

          if git apply --check ai_patch.patch 2>/dev/null; then
            print_success "Patch validation successful, applying patch"
            git apply ai_patch.patch
            git add -A
            print_success "Applied AI-generated patch successfully"
          else
            print_error "Patch validation failed, attempting fallback resolution"
            # Fallback: Try to resolve by accepting incoming changes
            for file in $(git ls-files -u | cut -f2 | sort -u); do
              print_status "Resolving conflicts in $file using fallback strategy..."
              # Try to merge intelligently by taking both sides when possible
              if [[ "$file" == *.md ]] || [[ "$file" == *README* ]] || [[ "$file" == *CHANGELOG* ]]; then
                # For documentation files, try to merge both sides
                git checkout --theirs "$file" 2>/dev/null || git checkout --ours "$file" 2>/dev/null || true
              else
                # For code files, prefer incoming changes
                git checkout --theirs "$file" 2>/dev/null || git checkout --ours "$file" 2>/dev/null || true
              fi
            done
            git add -A
            print_status "Applied fallback conflict resolution"
          fi

          if git ls-files -u | grep -q .; then
            print_error "Some conflicts remain unresolved"
            git status --porcelain
            exit 1
          fi

          git rebase --continue || print_status "Rebase completed with conflicts resolved"

      - name: Push updated branch
        if: steps.conflicts.outputs.has_conflict == 'false' || steps.apply_patch.conclusion == 'success' || steps.apply_claude_patch.conclusion == 'success'
        env:
          PR_BRANCH: ${{ matrix.pr.branch }}
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          print_status "Pushing updated branch $PR_BRANCH"
          git push --force-with-lease origin "${PR_BRANCH}"
          print_success "Successfully pushed updated branch"

      - name: Handle failed AI resolution
        if: steps.conflicts.outputs.has_conflict == 'true' && (steps.ai.outcome == 'failure' || steps.apply_patch.conclusion == 'failure') && steps.apply_claude_patch.conclusion != 'success'
        env:
          GH_TOKEN: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}
          PR_BRANCH: ${{ matrix.pr.branch }}
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          print_error "AI resolution failed, leaving PR for manual resolution"

          # Abort the rebase to clean state
          git rebase --abort 2>/dev/null || true

          gh pr comment ${{ matrix.pr.number }} --body "ðŸ¤– AI rebase workflow encountered conflicts that couldn't be automatically resolved. Manual intervention required.

          **Conflicted files:**
          $(git ls-files -u | cut -f2 | sort -u | sed 's/^/- /' 2>/dev/null || echo '- See workflow logs for details')

          **Next steps:**
          1. Check out the branch: \`git checkout $PR_BRANCH\`
          2. Resolve conflicts manually: \`git rebase ${{ inputs.base-branch }}\`
          3. Complete the rebase: \`git rebase --continue\`
          4. Push the resolved branch: \`git push --force-with-lease origin $PR_BRANCH\`

          **Troubleshooting:**
          - AI inference may have failed due to service availability
          - Check that your GitHub token has 'models' permission
          - The conflicts may be too complex for automatic resolution

          The rebase was attempted against: \`${{ inputs.base-branch }}\`" || true

      - name: Auto-merge PR (if applicable)
        if: steps.conflicts.outputs.has_conflict == 'false' || steps.apply_patch.conclusion == 'success' || steps.apply_claude_patch.conclusion == 'success'
        env:
          GH_TOKEN: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          if [ "${{ steps.conflicts.outputs.has_conflict }}" = "false" ] || [ "${{ steps.apply_patch.conclusion }}" = "success" ] || [ "${{ steps.apply_claude_patch.conclusion }}" = "success" ]; then
            print_status "Attempting to auto-merge PR #${{ matrix.pr.number }}"
            gh pr merge ${{ matrix.pr.number }} --auto --squash || print_error "Auto-merge failed - PR may need review"
          else
            print_status "Skipping auto-merge due to unresolved conflicts"
          fi

      - name: Comment with results
        if: always()
        env:
          GH_TOKEN: ${{ secrets.github-token || secrets.GITHUB_TOKEN }}
        run: |
          # Define CI status functions
          print_status() { echo "::notice ::[STATUS] $1"; }
          print_error() { echo "::error ::[ERROR] $1" >&2; }
          print_success() { echo "::notice ::[SUCCESS] $1"; }
          print_summary() { echo "::notice ::[SUMMARY] $1"; }

          if [ "${{ steps.conflicts.outputs.has_conflict }}" = "false" ]; then
            print_success "AI rebase workflow completed successfully - no conflicts found."
            gh pr comment ${{ matrix.pr.number }} --body "âœ… AI rebase workflow completed successfully - no conflicts found." || true
          elif [ "${{ steps.apply_patch.conclusion }}" = "success" ]; then
            print_success "AI rebase workflow resolved merge conflicts and updated the branch."
            gh pr comment ${{ matrix.pr.number }} --body "âœ… AI rebase workflow resolved merge conflicts and updated the branch.

            **Changes applied:**
            - Rebased branch \`${{ matrix.pr.branch }}\` onto \`${{ inputs.base-branch }}\`
            - GitHub AI successfully resolved conflicts
            - Branch has been force-pushed with resolved conflicts" || true
          elif [ "${{ steps.apply_claude_patch.conclusion }}" = "success" ]; then
            print_success "Claude fallback successfully resolved merge conflicts and updated the branch."
            gh pr comment ${{ matrix.pr.number }} --body "âœ… AI rebase workflow resolved merge conflicts using Claude fallback.

            **Changes applied:**
            - Rebased branch \`${{ matrix.pr.branch }}\` onto \`${{ inputs.base-branch }}\`
            - Claude AI successfully resolved conflicts after GitHub AI failed
            - Branch has been force-pushed with resolved conflicts" || true
          elif [ "${{ steps.ai.outcome }}" = "failure" ]; then
            print_error "AI inference service failed - manual resolution required"
          else
            print_error "Conflict resolution process encountered an error"
          fi

  summary:
    runs-on: ubuntu-latest
    needs: [find, rebase]
    steps:
      - name: Print summary
        run: |
          echo "Processed PRs: ${{ needs.find.outputs.list }}"
